<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Art Studio</title>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-database-compat.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0f0f0f; font-family: 'Inter', sans-serif; color: #fff; }
        #viewport { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        canvas { 
            background: white; 
            image-rendering: pixelated; 
            position: absolute;
            transform-origin: 0 0;
            box-shadow: 0 0 80px rgba(0,0,0,0.9);
        }
        .ui { 
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 100;
            background: rgba(30, 30, 30, 0.95); padding: 10px 25px;
            border-radius: 50px; display: flex; gap: 20px; align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid #444;
        }
        .tool-group { display: flex; gap: 8px; align-items: center; }
        button { 
            padding: 8px 15px; cursor: pointer; border: none; border-radius: 20px; 
            background: #333; color: white; transition: 0.2s; font-size: 13px;
        }
        button.active { background: #007bff; box-shadow: 0 0 10px rgba(0,123,255,0.5); }
        input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; }
        input[type="range"] { -webkit-appearance: none; width: 80px; height: 4px; background: #555; border-radius: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #007bff; border-radius: 50%; cursor: pointer; }
        .other-cursor { position: absolute; pointer-events: none; z-index: 50; font-size: 10px; text-shadow: 1px 1px 1px #000; }
        .dot { width: 4px; height: 4px; background: #ff4757; border-radius: 50%; }
        #footer { position: fixed; bottom: 15px; width: 100%; text-align: center; font-size: 11px; color: #666; pointer-events: none; }
        
        #preview-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 200; display: none;
            background: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); align-items: center; justify-content: center;
        }
        #preview-shape { border: 2px solid #000; }
        .shape-circle { border-radius: 50%; }
        .shape-square { border-radius: 0; }
        #myNickDisplay { font-size: 13px; font-weight: bold; color: #007bff; border-left: 1px solid #555; padding-left: 15px; }
    </style>
</head>
<body>

<div class="ui">
    <div class="tool-group">
        <button id="penBtn" class="active" onclick="setTool('pen')">Pen</button>
        <button id="eraBtn" onclick="setTool('eraser')">Eraser</button>
        <button id="fillBtn" onclick="setTool('fill')">Fill</button>
    </div>
    <div class="tool-group">
        <input type="color" id="colorPicker" value="#000000">
    </div>
    <div class="tool-group">
        <label style="font-size:11px">Size:</label>
        <input type="range" id="sizePicker" min="1" max="25" value="1">
        <span id="sizeVal" style="width:25px; font-size:11px">1px</span>
    </div>
    <div class="tool-group">
        <input type="checkbox" id="smoothCheck">
        <label style="font-size:11px">Stabilization</label>
    </div>
    <div class="tool-group">
        <span id="myNickDisplay"></span>
    </div>
</div>

<div id="preview-overlay">
    <div id="preview-shape"></div>
</div>

<div id="footer">LMB: Draw | RMB: Pan | SHIFT: Snap 45Â° | Scroll: Zoom</div>

<div id="viewport">
    <canvas id="canvas" width="2048" height="1024"></canvas>
    <div id="cursors"></div>
</div>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyCwk4Im8EtC_Eyu7dllwqTW54dwOXPhhf4",
        authDomain: "freedraw-ef17b.firebaseapp.com",
        databaseURL: "https://freedraw-ef17b-default-rtdb.firebaseio.com",
        projectId: "freedraw-ef17b",
        storageBucket: "freedraw-ef17b.firebasestorage.app",
        messagingSenderId: "155298386414",
        appId: "1:155298386414:web:f2a57cb5556a8e05c13eff"
    };
    
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, 2048, 1024);

    const viewport = document.getElementById('viewport');
    const cursorsLayer = document.getElementById('cursors');
    const sizePicker = document.getElementById('sizePicker');
    const sizeVal = document.getElementById('sizeVal');
    const smoothCheck = document.getElementById('smoothCheck');
    const colorPicker = document.getElementById('colorPicker');
    const previewOverlay = document.getElementById('preview-overlay');
    const previewShape = document.getElementById('preview-shape');
    const myNickDisplay = document.getElementById('myNickDisplay');

    let scale = 0.5;
    let camX = (window.innerWidth - 2048 * scale) / 2;
    let camY = (window.innerHeight - 1024 * scale) / 2;
    let isDrawing = false, isPanning = false;
    let currentTool = 'pen';
    let lastX = 0, lastY = 0;
    let brushX = 0, brushY = 0;
    let previewTimeout;
    let pendingPixels = {};
    let pendingCount = 0;
    let remoteUsers = {};

    const userName = prompt("Nickname:") || "User" + Math.floor(Math.random()*100);
    const userId = Math.random().toString(36).substring(7);
    myNickDisplay.innerText = userName;

    const userRef = db.ref('users/' + userId);
    userRef.onDisconnect().remove();

    function updateTransform() {
        canvas.style.transform = `translate(${camX}px, ${camY}px) scale(${scale})`;
        renderCursors();
    }

    function setTool(t) {
        currentTool = t;
        document.querySelectorAll('.ui button').forEach(b => b.classList.remove('active'));
        if(t === 'pen') { document.getElementById('penBtn').classList.add('active'); sizePicker.max = 25; }
        else if(t === 'eraser') { document.getElementById('eraBtn').classList.add('active'); sizePicker.max = 50; }
        else { document.getElementById('fillBtn').classList.add('active'); }
        showSizePreview();
    }

    sizePicker.oninput = () => {
        sizeVal.innerText = sizePicker.value + 'px';
        showSizePreview();
    };

    function showSizePreview() {
        const size = parseInt(sizePicker.value);
        const visualSize = size * scale;
        previewShape.style.width = Math.max(visualSize, 1) + 'px';
        previewShape.style.height = Math.max(visualSize, 1) + 'px';
        previewShape.className = currentTool === 'eraser' ? 'shape-square' : 'shape-circle';
        
        previewOverlay.style.display = 'flex';
        clearTimeout(previewTimeout);
        previewTimeout = setTimeout(() => {
            previewOverlay.style.display = 'none';
        }, 800);
    }

    function getCoords(e) {
        return {
            x: (e.clientX - camX) / scale,
            y: (e.clientY - camY) / scale
        };
    }

    function hexToRgb(hex) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    function flushPixels() {
        if (pendingCount > 0) {
            db.ref('pixels').update(pendingPixels);
            pendingPixels = {};
            pendingCount = 0;
        }
    }

    function drawLine(x1, y1, x2, y2, color, size, isSquare) {
        const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        const steps = Math.ceil(dist * 2);
        if (steps === 0) {
            applyBrush(x1, y1, color, size, isSquare);
            return;
        }
        for (let i = 0; i <= steps; i++) {
            const px = x1 + (x2 - x1) * (i / steps);
            const py = y1 + (y2 - y1) * (i / steps);
            applyBrush(px, py, color, size, isSquare);
        }
    }

    function applyBrush(cx, cy, color, size, isSquare) {
        const r = size / 2;
        const rSq = r * r;
        ctx.fillStyle = color;
        for (let ix = -Math.ceil(r); ix <= Math.ceil(r); ix++) {
            for (let iy = -Math.ceil(r); iy <= Math.ceil(r); iy++) {
                const dx = ix, dy = iy;
                if (isSquare || (dx * dx + dy * dy <= rSq)) {
                    const px = Math.floor(cx + ix);
                    const py = Math.floor(cy + iy);
                    const key = `${px}_${py}`;
                    
                    if (pendingPixels[key] !== color) {
                        pendingPixels[key] = color;
                        pendingCount++;
                        ctx.fillRect(px, py, 1, 1);
                    }
                }
            }
        }
    }

    function floodFill(startX, startY, fillHex) {
        const x = Math.floor(startX);
        const y = Math.floor(startY);
        if (x < 0 || y < 0 || x >= 2048 || y >= 1024) return;

        const imgData = ctx.getImageData(0, 0, 2048, 1024);
        const data = imgData.data;
        const targetIdx = (y * 2048 + x) * 4;
        const targetR = data[targetIdx], targetG = data[targetIdx+1], targetB = data[targetIdx+2];
        const fillRgb = hexToRgb(fillHex);
        
        if (targetR === fillRgb.r && targetG === fillRgb.g && targetB === fillRgb.b) return;

        const visited = new Uint8Array(2097152);
        const queue = [x, y];
        const updates = {};
        let count = 0;
        
        while(queue.length > 0 && count < 50000) {
            const cy = queue.pop();
            const cx = queue.pop();
            
            if (cx < 0 || cy < 0 || cx >= 2048 || cy >= 1024) continue;
            
            const vIdx = cy * 2048 + cx;
            if (visited[vIdx]) continue;
            visited[vIdx] = 1;
            
            const idx = vIdx * 4;
            
            if (data[idx] === targetR && data[idx+1] === targetG && data[idx+2] === targetB) {
                data[idx] = fillRgb.r; data[idx+1] = fillRgb.g; data[idx+2] = fillRgb.b;
                updates[`${cx}_${cy}`] = fillHex;
                queue.push(cx+1, cy, cx-1, cy, cx, cy+1, cx, cy-1);
                count++;
            }
        }
        
        if (Object.keys(updates).length > 0) {
            ctx.putImageData(imgData, 0, 0);
            db.ref('pixels').update(updates);
        }
    }

    viewport.oncontextmenu = (e) => e.preventDefault();
    viewport.onmousedown = (e) => {
        const coords = getCoords(e);
        if (e.button === 0) {
            if (currentTool === 'fill') {
                floodFill(coords.x, coords.y, colorPicker.value);
            } else {
                isDrawing = true;
                brushX = coords.x; 
                brushY = coords.y;
                lastX = coords.x; 
                lastY = coords.y;

                const color = currentTool === 'eraser' ? '#FFFFFF' : colorPicker.value;
                applyBrush(lastX, lastY, color, parseInt(sizePicker.value), currentTool === 'eraser');
                
                if (pendingCount > 150) flushPixels();
            }
        } else if (e.button === 2) isPanning = true;
    };

    window.onmousemove = (e) => {
        const target = getCoords(e);
        
        if (isDrawing) {
            const lerpFactor = smoothCheck.checked ? 0.15 : 1.0;
            brushX += (target.x - brushX) * lerpFactor;
            brushY += (target.y - brushY) * lerpFactor;
            
            let finalX = brushX, finalY = brushY;
            if (e.shiftKey) {
                const dx = finalX - lastX, dy = finalY - lastY;
                const angle = Math.round(Math.atan2(dy, dx) / (Math.PI / 4)) * (Math.PI / 4);
                const d = Math.sqrt(dx*dx + dy*dy);
                finalX = lastX + Math.cos(angle) * d;
                finalY = lastY + Math.sin(angle) * d;
            }

            const color = currentTool === 'eraser' ? '#FFFFFF' : colorPicker.value;
            drawLine(lastX, lastY, finalX, finalY, color, parseInt(sizePicker.value), currentTool === 'eraser');

            if (pendingCount > 150) flushPixels();

            lastX = finalX; lastY = finalY;
        }
        
        if (isPanning) {
            camX += e.movementX; camY += e.movementY;
            updateTransform();
        }
        
        userRef.set({ x: target.x, y: target.y, name: userName, ts: Date.now() });
    };

    window.onmouseup = (e) => {
        if (isDrawing && currentTool !== 'fill') {
            const target = getCoords(e);
            const color = currentTool === 'eraser' ? '#FFFFFF' : colorPicker.value;
            drawLine(lastX, lastY, target.x, target.y, color, parseInt(sizePicker.value), currentTool === 'eraser');
            
            flushPixels();
        }
        
        isDrawing = false;
        isPanning = false;
    };

    viewport.onwheel = (e) => {
        e.preventDefault();
        const target = getCoords(e);
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        
        scale = Math.min(Math.max(0.1, scale * factor), 20);
        
        camX = e.clientX - target.x * scale;
        camY = e.clientY - target.y * scale;
        
        updateTransform();
        if (previewOverlay.style.display === 'flex') showSizePreview();
    };

    db.ref('pixels').on('child_added', (s) => {
        const [x, y] = s.key.split('_');
        ctx.fillStyle = s.val();
        ctx.fillRect(x, y, 1, 1);
    });

    db.ref('pixels').on('child_changed', (s) => {
        const [x, y] = s.key.split('_');
        ctx.fillStyle = s.val();
        ctx.fillRect(x, y, 1, 1);
    });

    function renderCursors() {
        cursorsLayer.innerHTML = '';
        const now = Date.now();
        
        for (let id in remoteUsers) {
            const u = remoteUsers[id];
            if (!u.ts || now - u.ts > 60000) continue;
            
            const screenX = u.x * scale + camX;
            const screenY = u.y * scale + camY;
            
            const div = document.createElement('div');
            div.className = 'other-cursor';
            div.style.left = screenX + 'px'; 
            div.style.top = screenY + 'px';
            div.innerHTML = `<div class="dot"></div>${u.name}`;
            cursorsLayer.appendChild(div);
        }
    }

    db.ref('users').on('value', (s) => {
        const data = s.val() || {};
        remoteUsers = {};
        for (let id in data) {
            if (id !== userId) {
                remoteUsers[id] = data[id];
            }
        }
        renderCursors();
    });

    setInterval(() => {
        if (!isDrawing && !isPanning) {
            userRef.update({ ts: Date.now() });
        }
    }, 10000);

    updateTransform();
</script>

</body>
</html>
